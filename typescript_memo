ルール
・抽象的に書かない
・コピペしない
・例文を書く
・文法以外は日本語で書く

パラメーター

オブジェクト
設計書みたいなもの
例文
let user = {
  name: 'tomo',
  age:30,
}; // こちらは変数
例文の中括弧内をオブジェクトと呼ぶ
{
  name: 'tomo',
  age:30,
}; // こちらがオブジェクト

プロパティ
オブジェクトの内の機能名の事
オブジェクト内のキーの事
例文
let user = {
  キー: 値（機能）
}

typeof

ジェネリクス
型を引数として受け取れる仕組み
例文
function 関数名<T>(引数: <T>): <T> {
  return 引数
}
console.log(関数名<型>(型よって数字、文字列、真偽値など変わる))
function 関数名の後に<T>「TでもUでもよい」を入力することで,出力時に「T」を型に置き換える「console.log(関数名<型>)」ことができる。
型部分に「string」を書くと「console.log(関数名<string>('hello')」型付けされた文字列が出力できる。
型推論も可能
function 関数名<T>(引数: <T>): <T> {
  return 引数
}
console.log(関数名({ プロパティ: 値})); //値に文字列や数字を入れることで型推論される
function 関数名<T>の<T>は<T, U, V>など何個も引数が書けるが出力時に型注釈しないとunkwon型になる。
例文
function 関数名<T, U>(引数: <T>): <T> {
  return 引数
}
console.log(関数名({ プロパティ: 値})); //これだとTの型しか出力されない為、Uはunkwon型なる
console.log(関数名<{ プロパティ: 型 }, 型>({ プロパティ: 値})); //これでUの方も出力される

extends
型パラメーターに制約をつける
例文
function 関数名<T extends { プロパティ: 型}>(引数: <T>): <T> {
  return 引数
}; // Tにextends { プロパティ: 型}つけることで値に型を指定する
console.log(関数名({ プロパティ: 値}));
型パラメーター
例文
{ プロパティ: 型}
パラメーターの値を型に変えたパラメーターの事

keyof
型のエイリアスにオブジェクトのキー（プロパティ）入れると、エイリアスにユニオン型で代入してくれる。
例文
type K(型エイリアス) = keyof { キー1: 型; キー2: 型 }
結果
type K = "キー1" | "キー2"
分からなかった部分
extendsとkeyofの組み合わせ

Utility型
インポートしなくてもtypescriptで内蔵している型のライブラリ
例文
interface 型エイリアス {
  プロパティ1: 型
  プロパティ2: 型
}
type 型の変数 = Partial<型エイリアス>; //PartialはUtility型が内蔵
結果
type 型の変数 = {
    プロパティ1?: 型;
    プロパティ2?: 型;
type 型の変数 = ReadOnly<型エイリアス>; //ReadOnlyはUtility型が内蔵
type 型の変数 = {
    ReadOnly プロパティ1: 型;
    ReadOnly プロパティ2: 型;

MappedTypes
型を繰り返し扱うための文
例文
type Mappedtype = {
  [変数 in '文字列リテラル' | '文字列リテラル2']: 変数
}; // オブジェクト中に構文で書く
結果
: 変数にすると文字列リテラルが繰り返される
type Mappedtype = {
    文字列リテラル: "文字列リテラル";
    文字列リテラル2: "文字列リテラル2";
}
例文
type Mappedtype = {
  [変数 in '文字列リテラル' | '文字列リテラル2']: 型
}; // オブジェクト中に構文で書く
結果
: 型にすると型が繰り返される
type Mappedtype = {
    文字列リテラル: string;
    文字列リテラル2: string;
}